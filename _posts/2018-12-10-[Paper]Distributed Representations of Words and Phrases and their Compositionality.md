---
    author: LuckyGong
    comments: true
    date: 2018-12-10 20:27
    layout: post
    title: Paper-Distributed Representations of Words and Phrases and their Compositionality
    categories:
    - nlp
    tags:
    - nlp
    - paper
---

# Abstract

- 统计语言建模的目标是学习语言中单词序列的联合概率函数。由于维度的诅咒，这是很难的，原因：
  - 存在很多为0的条件概率
  - 测试单词序列与训练单词序列不同
  - 参数过多，如果一个人想要对自然语言中单词表大小为100000的10个相连的词建立联合分布模型，将会有100 00010 − 1 = 1050 – 1个自由参数。
- n-gram通过连接训练集中看到的非常短的重叠序列获得泛化
- 我们的方法：学习词的分布表示来对抗维度诅咒，这允许模型通过训练语句对指数级语义相关的句子进行建模。该模型同时学习两部分：
  - 每个单词的分布式表示
  - 单词序列的概率函数

- 模型可以得到泛化是因为一个从未出现的词序列，如果它是由与它相似的词组成过已经出现的句子的话，那么它获得较高的概率。

# 1.Introduction

- 当对连续变量建模时，更容易得到泛化（如光滑的类的函数像多层神经网络或Gaussian混合模型），因为要学习的函数可以被期望将有一些LO- CAL的平滑性。对于离散的空间，泛化结构并不明显：这些离散随机变量的任何变化可能对要估计的函数的值产生极大的影响，并且当每个离散的变量取值范围很大时，大多数观察到的对象在汉明距离上是几乎无穷远的。

## 1.0 统计语言模型

- 由条件概率表示的语言模型公式：

  - w_1^T：前T个词
  - w_t：第t个词
  - W_1^(t-1)：前t-1个词

  ![](http://images.cnitblog.com/blog/590456/201409/012034441256455.png)

- n-gram统计语言模型公式：

  ![](http://images.cnitblog.com/blog/590456/201409/012035086572994.png)

  - 存在的问题：新的n-gram出现时，会出现0概率。
  - 现有的解决方案：可以“使用更小的gram”（tri-gram，一个新的词序列是通过“粘合”非常短的重叠的在训练语料中出现频繁的字片段组成。获得下一个片段的概率的规则是隐式的回退或者打折后的n-gram算法。）或者“平滑”解决。

- 现有的解决方案存在的问题：

  - 没有考虑超过一个或两个词的上下文
  - 没有考虑词之间的相似性（如：The cat is walking in the bedroom 可以生成 A dog was running in a room，这俩句子差不多）

## 1.1分布式表示来对抗维度诅咒

- 该方法步骤：
  - 为在词表中的每一个词分配一个分布式的词特征向量
  - 词序列中出现的词的特征向量表示的词序列的联合概率函数
  - 学习词特征向量和概率函数的参数
- 每个词关联向量空间的一个点。特征的数量远远小于词表的大小。

## 1.2神经网络进行分布式训练

- 使用神经网络对高维离散分布建模已经被发现可以有效的学习其联合概率。

- 联合概率被分解为条件概率的乘积：

  - g(x)：神经网络函数
  - gi(x)：第i个输出块，计算表达给定之前Z，Zi的条件概率的参数

  ![](http://images.cnitblog.com/blog/590456/201409/012037157979085.png)

# 2.网络模型

- 符号：
  - w_1,...,w_T：训练数据，T个单词
  - V：词汇表
  - |V|：词表的大小
  - θ：模型参数
  - R(θ)：正则项
  - W：|V|×(n-1)m的矩阵
  - U：|V|×h的矩阵
  - d：h维的列向量
  - H：h×(n-1)m的矩阵
  - b：|V|维的列向量
  - h：隐藏单元数目
  - ε：学习速度

- 模型：

  - 组成：
    - 第一部分：一个映射C，从词表中的任意元素i到实向量C(i)∈Rm。它代表关联词表中词的分布特征向量。在实践中，C被表示成一个|V|×m的自由参数矩阵。 
    - 第二部分：词上的概率函数g，从输入序列的词的“上文”（前n个词，n-gram）特征向量，(C(wt-n+1),…,C(wt-1))，到词表中下一个词i的条件概率分布。g的输出是一个向量，向量的第i个元素估计概率![](http://images.cnitblog.com/blog/590456/201409/012055383919237.png)
  - 公式：

  ![](http://images.cnitblog.com/blog/590456/201409/012053476259576.png)

  ![](http://images.cnitblog.com/blog/590456/201409/012056073913245.png)

  ![](http://images.cnitblog.com/blog/590456/201409/012058338752792.png)

  ![](http://images.cnitblog.com/blog/590456/201409/012058224075529.png)

  - 约束：
    - ![](http://images.cnitblog.com/blog/590456/201409/012054013287723.png)
    - ![](http://images.cnitblog.com/blog/590456/201409/012054067979019.png)
  - 困惑度：1/P(w_t|w_1^(t-1)) 
  - 图示：

  ![](http://images.cnitblog.com/blog/590456/201409/012056252978173.png)

  - 参数量：自由参数的数量是词表V大小的线性函数。自由参数的数量也是序列长度n的线性函数。共有参数：|V|(1 + nm + h) + h(1 + (n - 1)m)个，其中起决定作用的是：|V|(nm + h) 。

- 优化目标：最大化对数似然

![](http://images.cnitblog.com/blog/590456/201409/012058071417127.png)

- 优化算法：梯度下降。

![](http://images.cnitblog.com/blog/590456/201409/012058568448075.png)

# 3.并行实现

- 为什么要并行：计算的总量远远大于n-gram。
  - 在n-gram模型中，获得特定的p(wt|w_(t-1),…,w_(t-n+1))由于简单的归一化不需要计算词表中所有的概率。
  - 神经网络计算的瓶颈主要是在输出层。

## 3.1数据并行处理

- 当通信开销较低的时候，我们选择数据并行化的实现方式。
- 每个处理器工作在不同的数据子集。每个处理器计算它拥有的训练样例的梯度，执行随机梯度下降算法更新内存中共享的参数。
- 用异步不用同步。
- 大型共享内存计算机是很昂贵的，并且它们的处理器的速度倾向于比CPU集群落后。因此我们可以在高速的网络集群上得到更快的训练。

## 3.2参数并行处理

- 如果并行计算机是一个CPU的网络，我们通常支付不起过于频繁的参数交换的开销，因为参数的规模是百兆级别的，这将消耗大量的时间。
- 取而代之我们选择参数并行处理，特别的，参数是输出单元的参数，因为这是在我们的架构中绝大多数计算发生的地方。每个CPU负责计算一个未正则化概率的输出子集。
- 这种策略允许我们实现一个通信开销微不足道的并行的随机梯度下降算法。CPU本质上需要交换两种数据：（1）输出层的正则化因子，（2）隐藏层的梯度和词特征层。所有的CPU都复制在输出层之前的计算，然而这些计算比起总的计算量是微不足道的。

